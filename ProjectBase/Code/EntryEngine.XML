<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EntryEngine</name>
    </assembly>
    <members>
        <member name="M:EntryEngine.Utility.LengthFloat(System.Single,System.Int32)">
            <summary>
            显示指定小数点位数的float值
            </summary>
            <param name="value">值</param>
            <param name="length">要显示的小数点后面的位数</param>
            <returns>指定位数的float字符串</returns>
        </member>
        <member name="M:EntryEngine.Utility.LengthString(System.String,System.Int32)">
            <summary>
            显示指定长度的字符串
            </summary>
            <param name="value">字符串</param>
            <param name="length">要显示的长度</param>
            <returns>截取长度后的字符串</returns>
        </member>
        <member name="M:EntryEngine.Utility.GetFloatLength(System.Single)">
            <summary>
            获得一个浮点数的位数
            </summary>
            <param name="value">一个浮点值</param>
            <returns>浮点数的位数</returns>
        </member>
        <member name="M:EntryEngine.Utility.Switch``1(System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            切换排序
            </summary>
            <typeparam name="T">任意类型</typeparam>
            <param name="list">要切换的集合</param>
            <param name="order">切换的顺序</param>
        </member>
        <member name="M:EntryEngine.Utility.SortQuit``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Boolean,System.Func{``0,System.Int32})">
            <summary>
            快速排序
            </summary>
            <typeparam name="T">排序类型</typeparam>
            <param name="array">要排序的数组</param>
            <param name="low">排序起始项索引</param>
            <param name="high">排序结束项索引</param>
            <param name="asc">升序True/降序False</param>
            <param name="comparer">要比较的对象代数</param>
        </member>
        <member name="M:EntryEngine.Utility.SortOrderDesc``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Int32})">
            <summary>
            稳定排序，同分时顺序不变
            </summary>
        </member>
        <member name="P:EntryEngine.Utility.UnixTimestamp">
            <summary>2038年将超过int最大值</summary>
        </member>
        <member name="T:EntryEngine.UI.EUIType">
            <summary>子类控件会默认采用父类样式，例如0x11会采用0x10的样式</summary>
        </member>
        <member name="M:EntryEngine.UI.UIStyle.AddStyle(EntryEngine.UI.EUIType,System.Action{EntryEngine.UI.UIElement})">
            <summary>添加某类UI控件的默认样式</summary>
            <param name="uiType">UI控件类型</param>
            <param name="setStyle">设置UI样式的方法，返回true则设置了样式（例如CheckBox的单选框和复选框就可能类型都是CheckBox但是样式不同）</param>
        </member>
        <member name="F:EntryEngine.UI.UIFlowLayout.Line">
            <summary>占满一行</summary>
        </member>
        <member name="T:EntryEngine.UI.UIElement">
            <summary>
            简单，高性能绘制
            1. 不用支持旋转、镜像
            2. 非特殊情况下，不使用Transform、Shader和Scissor
            
            4种状态的Rectangle
            1. 相对于 父容器 / 屏幕
            2. 完整 / 裁剪
            
            更新顺序，绘制顺序，绘制覆盖顺序为逆序，所以可能需要将更新改为逆序
            
            每帧动作顺序
            1. Childs从后往前Event, Parent.Event
            2. Parent.Update, Childs从后往前Update
            3. Parent.Draw, Childs从前往后Draw
            
            IsClip及其相关参数的有不明确的地方，需要修改
            </summary>
        </member>
        <member name="M:EntryEngine.Tree`1.ForParentPriority(`0,System.Func{`0,System.Boolean},System.Action{`0})">
            <summary>For：Childs里的所有元素</summary>
        </member>
        <member name="M:EntryEngine.Tree`1.ForeachParentPriority(`0,System.Func{`0,System.Boolean},System.Action{`0})">
            <summary>Foreach：可以重写GetEnumerator影响此结果</summary>
        </member>
        <member name="M:EntryEngine.Tree`1.ForRootToLeaf(`0,System.Action{`0},System.Action{`0})">
            <summary>父节点全部循环完后，再循环父节点的</summary>
        </member>
        <member name="F:EntryEngine.UI.UIElement.needUpdateHover">
            <summary>
            当一个子场景在主场景中时
            Entry对场景的更新是从后往前的，即子场景会先更新
            对于Touch来说，前一帧没有按下时，自场景和父场景的Hover状态都是false
            当前帧按下时，父场景由于Hover是false，会导致子场景的Hover也是false
            所以此时应该像needUpdateLocalToWorld时先去更新父场景的Hover状态
            </summary>
        </member>
        <member name="F:EntryEngine.UI.UIElement.finalClip">
            <summary>viewport in Parent</summary>
        </member>
        <member name="F:EntryEngine.UI.UIElement.finalViewClip">
            <summary>graphics viewport in screen</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Enter">
            <summary>鼠标进入区域内</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Move">
            <summary>鼠标在区域内移动</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Exit">
            <summary>鼠标离开区域</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Focus">
            <summary>获得焦点</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Blur">
            <summary>失去焦点</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Hover">
            <summary>鼠标在区域内（不包含进入区域的一次）</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.UnHover">
            <summary>鼠标不在区域内</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Click">
            <summary>鼠标左键按下</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Pressed">
            <summary>鼠标左键按住拖拽，并指针在目标范围内</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Drag">
            <summary>鼠标左键按住拖拽</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Clicked">
            <summary>鼠标左键抬起，需要触发过点击</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Released">
            <summary>鼠标左键抬起</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.DoubleClick">
            <summary>鼠标左键双击</summary>
        </member>
        <member name="E:EntryEngine.UI.UIElement.Keyboard">
            <summary>键盘按键状态改变</summary>
        </member>
        <member name="P:EntryEngine.UI.UIElement.PivotAlignmentX">
            <summary>左0/中1/右2</summary>
        </member>
        <member name="P:EntryEngine.UI.UIElement.PivotAlignmentY">
            <summary>上0/中1/下2</summary>
        </member>
        <member name="P:EntryEngine.UI.UIElement.IsClip">
            <summary>约束子控件是否在自己的可视范围内才让有效</summary>
        </member>
        <!-- 对于成员“T:EntryEngine.UI.EPhase”忽略有格式错误的 XML 注释 -->
        <member name="T:EntryEngine.UI.EState">
            <summary>
            场景更新的状态
            
            参数
                None:
                    继续更新
                    
                Dialog:
                    对话框，不更新其它场景事件
                    
                Block:
                    对话框，完全跳过其它场景更新
                    
                Cover:
                    遮罩，覆盖除主菜单外的所有自己下面的对话框，使其不绘制也不更新
                    
                CoverAll:
                    完全跳过其它菜单的绘制和更新
                    
                Break:
                    可以移除此场景
                    
            	Dispose:
            		移除场景并释放资源
            		
            	Release:
            		移除场景并释放资源及其在Entry内的缓存
            </summary>
        </member>
        <member name="T:EntryEngine.UI.EShowPosition">
            <summary>
            只保留居中和自定义
            </summary>
        </member>
        <member name="F:EntryEngine.UI.Panel.Inertia">
            <summary>惯性移动量，拖拽时会自动维护，也可以自定义设置这个值</summary>
        </member>
        <member name="F:EntryEngine.UI.Panel.ScrollWheelSpeed">
            <summary>鼠标滑轮的滑动像素，0则不能使用鼠标滑轮</summary>
        </member>
        <member name="M:EntryEngine.UI.Panel.DoMove(System.Single,System.Single,System.Boolean@,System.Boolean@)">
            <summary>移动面板</summary>
            <param name="moveX">X移动量</param>
            <param name="moveY">Y移动量</param>
            <param name="boundaryX">X是否已到边界</param>
            <param name="boundaryY">Y是否已到边界</param>
        </member>
        <member name="P:EntryEngine.UI.Panel.DragFriction">
            <summary>拖拽惯性摩擦，惯性力*=摩擦力；0则立刻停下，1则停不下来</summary>
        </member>
        <member name="M:EntryEngine.UI.UIScene.OnPhaseShowing">
            <summary>
            Scene进入到Entry
            </summary>
            <param name="previous">切换菜单则是前一个主菜单，二级菜单则为当前主菜单</param>
        </member>
        <member name="M:EntryEngine.UI.UIScene.OnPhaseEnded">
            <summary>
            Scene从Entry移除
            </summary>
            <param name="next">换菜单则是即将切换到的菜单，否则为null</param>
        </member>
        <member name="M:EntryEngine.UI.UIScene.LoadAsync(EntryEngine.AsyncLoadContent)">
            <summary>
            <para>异步加载协程，在Load中调用</para>
            <para>1. LoadAsync 完全不阻断协程</para>
            <para>2. yield return LoadAsync 阻断协程直到异步加载完成，可以自定义ICoroutine来实现加载条</para>
            </summary>
            <param name="async">异步加载状态</param>
            <returns>阻断协程</returns>
        </member>
        <member name="M:EntryEngine.UI.UIScene.OnRemovedBy(EntryEngine.UI.UIElement)">
            <summary>
            场景在其它场景里时，被Remove或Clear时需要关闭此场景
            </summary>
        </member>
        <member name="M:EntryEngine.EntryService.TimerCoroutine(EntryEngine.ICoroutine,EntryEngine.ICoroutine)">
            <summary>
            先timer，后tick
            </summary>
        </member>
        <member name="F:EntryEngine.Entry.IsFixedTimeStep">
            <summary>每帧经过的时间：true:Platform.FrameRate/false:实际经过时间</summary>
        </member>
        <member name="M:EntryEngine.Entry.SwitchMainScene``2">
            <summary>
            使用过场场景切换场景
            </summary>
            <typeparam name="T">要切换的主场景类型</typeparam>
            <typeparam name="U">过场场景类型</typeparam>
            <returns>主场景</returns>
        </member>
        <member name="F:EntryEngine.Serialize.Serializable.RecognitionChildType">
            <summary>
            <para>true: value.GetType() != type时，则将序列化value.GetType()的类型名以便反序列化</para>
            <para>false: 数据库自动生成的数据表子类型可能直接用于传输，此时序列化类型名将加大传输数据量</para>
            </summary>
        </member>
        <member name="T:EntryEngine.ITypist">
            <summary>
            只有实现此接口的对象允许使用文本输入设备
            </summary>
        </member>
        <member name="M:EntryEngine.ITypist.Filter(System.Char@)">
            <summary>文字筛选，用于例如只能输入数字</summary>
            <param name="c">允许替换的单个字符</param>
            <returns>true: 被筛选掉的非法字符 / false: 合法字符</returns>
        </member>
        <member name="M:EntryEngine.ITypist.OnStop(System.String,System.String)">
            <summary>设备关闭时回调源的处理程序</summary>
            <param name="result">最终文本属性</param>
        </member>
        <member name="P:EntryEngine.ITypist.ActiveSelect">
            <summary>激活设备时是否要选中所有文字</summary>
        </member>
        <member name="P:EntryEngine.ITypist.Font">
            <summary>计算光标位置</summary>
        </member>
        <member name="P:EntryEngine.ITypist.Text">
            <summary>未经处理的源文字</summary>
        </member>
        <member name="P:EntryEngine.ITypist.DisplayText">
            <summary>经过处理显示的文字</summary>
        </member>
        <member name="P:EntryEngine.ITypist.Readonly">
            <summary>只读则不允许输入和删除操作，不过可以复制</summary>
        </member>
        <member name="P:EntryEngine.ITypist.BreakLine">
            <summary>控制是否超出文字区域自动换行，用于计算光标位置</summary>
        </member>
        <member name="P:EntryEngine.ITypist.Multiple">
            <summary>用于判断回车是换行还是确定</summary>
        </member>
        <member name="P:EntryEngine.ITypist.IsMask">
            <summary>遮挡(密码)模式时不可复制选中</summary>
        </member>
        <member name="P:EntryEngine.ITypist.TextArea">
            <summary>文字区域，用于计算光标位置</summary>
        </member>
        <member name="P:EntryEngine.ITypist.ViewArea">
            <summary>显示区域，用于点击取消编辑</summary>
        </member>
        <member name="P:EntryEngine.ITypist.MaxLength">
            <summary>限制输入最大长度</summary>
        </member>
        <member name="P:EntryEngine.ITypist.IsActive">
            <summary>使用输入设备的控件是否激活，用于控制设备自动关闭</summary>
        </member>
        <member name="F:EntryEngine.UI.NumberBox.DragStep">
            <summary>y+1px时对应的Value变化</summary>
        </member>
        <member name="F:EntryEngine.Serialize.Binary.Long52Bit">
            <summary>Long类型采用52位长度</summary>
        </member>
        <member name="M:EntryEngine.Serialize.ByteReader.ReadArray(System.Array@,System.Type)">
            <summary>
            元素类型（非数组类型）
            </summary>
            <param name="array">要赋值的数组</param>
            <param name="type">数组元素类型，int[]则传typeof(int)</param>
        </member>
        <member name="T:EntryEngine.Serialize.ByteRefWriter">
            <summary>支持的引用：对象，对象数组</summary>
        </member>
        <member name="F:EntryEngine.Serialize.ByteRefWriter.onSerialize">
            <summary>自定义类型序列化，若进行了序列化，应该返回true</summary>
        </member>
        <member name="M:EntryEngine.Serialize.ByteRefReader.INNER_READER.ReadObject(System.Type)">
            <summary>由于读取数组不一样，需要先读取引用，所以封装成内部类，仅允许ReadObject操作</summary>
        </member>
        <member name="F:EntryEngine.Network.LinkBinary.Heartbeat">
            <summary>
            <para>大于0. 到时间会发送心跳包，包发不出去将结束心跳</para>
            <para>等于0. 不关心心跳</para>
            <para>小于0. 到时间(绝对值)会直接视为断线（抛出ExceptionHeartbeatStop异常）</para>
            </summary>
        </member>
        <member name="F:EntryEngine.Network.LinkHttpRequest.KeepAlive">
            <summary>保持一个给服务端用于推送消息的长连接时间，小于等于0则不保持长连接</summary>
        </member>
        <member name="F:EntryEngine.Network.Connector.ReconnectInterval">
            <summary>重连间隔，单位ms</summary>
        </member>
        <member name="F:EntryEngine.Network.Connector.WaitResponse">
            <summary>等待服务器回应登录数据的时间，单位ms</summary>
        </member>
        <member name="E:EntryEngine.Network.Connector.OnConnectData">
            <summary>写入连接数据；是否断线重连；返回null则断开连接</summary>
        </member>
        <member name="E:EntryEngine.Network.Connector.OnConnectSuccess">
            <summary>连接成功，通过返回的数据构建Agent；是否断线重连</summary>
        </member>
        <member name="E:EntryEngine.Network.Connector.OnConnectFault">
            <summary>连接失败；是否断线重连，重连次数，返回是否继续重连</summary>
        </member>
        <member name="E:EntryEngine.Network.Connector.OnAgentError">
            <summary>网络交互协议异常</summary>
        </member>
        <member name="T:EntryEngine.Network.LinkBinaryLocal">
            <summary>将本地写入的数据进行读取</summary>
        </member>
        <member name="T:EntryEngine.Network.LinkRepeatPreventor">
            <summary>保护短时间内不重复发相同的数据</summary>
        </member>
        <member name="T:EntryEngine.Network.LinkBatchDelay">
            <summary>一段时间内若有其他包则一起写入后发送</summary>
        </member>
        <member name="E:EntryEngine.Network.HttpRequestPost.OnSend">
            <summary>异步</summary>
        </member>
        <member name="E:EntryEngine.Network.HttpRequestPost.OnSent">
            <summary>异步</summary>
        </member>
        <member name="E:EntryEngine.Network.HttpRequestPost.OnReceived">
            <summary>异步</summary>
        </member>
        <member name="E:EntryEngine.Network.HttpRequestPost.OnError">
            <summary>异步</summary>
        </member>
        <member name="M:EntryEngine.Network._DATABASE.UpdateCascadeParentID(System.Collections.Generic.IEnumerable{EntryEngine.Network.IInnerCascade},System.Int32,System.Int32)">
            <summary>级联父级更换</summary>
            <param name="items">完整级联列表，包含所有级别</param>
            <param name="id">要改的目标层级</param>
            <param name="newParentID">新的父级</param>
        </member>
        <member name="M:EntryEngine.Network._DATABASE.Database.CreateConnection">
            <summary>已打开可使用的数据库连接</summary>
        </member>
        <member name="M:EntryEngine.Game.BAG`1.Add(System.Int32,System.Int32,`0@)">
            <summary>数量变化，正数直接加，负数检查数量后减</summary>
        </member>
        <member name="M:EntryEngine.Game.BAG`1.Insert(`0)">
            <summary>数量添加，没有则加入背包</summary>
            <returns>是否新增或删除</returns>
        </member>
        <member name="M:EntryEngine.Game.BAG`1.Update(System.Int32,System.Int32)">
            <summary>数量变成</summary>
        </member>
        <member name="M:EntryEngine.Game.BAG`1.Save(System.Collections.Generic.List{EntryEngine.Game.BAG_PACKAGE},System.Int32)">
            <summary>保存数据变动</summary>
            <param name="output">SQL数据包，包括语句和参数</param>
            <param name="batchLength">分批打包的sql语句长度，超过长度则分批，-1则不分批</param>
            <returns>是否有保存数据</returns>
        </member>
        <member name="T:EntryEngine.Game.ITEM">
            <summary>掉落权重变化在_MATH.WeightVary</summary>
        </member>
        <member name="M:EntryEngine.Game.ITEM.Drop(System.Collections.Generic.IEnumerable{EntryEngine.Game.IDrop},EntryEngine._RANDOM.Random,EntryEngine.Game.DROP[])">
            <summary>掉落列表中掉落道具</summary>
            <param name="list">掉落列表</param>
            <param name="random">随机对象</param>
            <param name="weightVary">权重变化量，可通过_MATH.WeightVary计算，权重变化的ID在掉落列表中不存在时，权重变化不起作用</param>
            <returns>掉落的道具，ID为0则代表空道具</returns>
        </member>
        <member name="T:EntryEngine.Game.T_S_ONLINE">
            <summary>统计时间点的在线人数</summary>
        </member>
        <member name="M:EntryEngine.Game.T_S_ONLINE.GetQuarter(System.DateTime)">
            <summary>
            <para>int quarter = T_S_ONLINE.GetQuarter(ref time);</para>
            <para>if (quarter == 0) // 新的一天第一次插入数据库</para>
            <para>else db.ExecuteNonQuery(string.Format("UPDATE T_S_ONLINE SET Quarter{0} = {1} WHERE Time = @p0", quarter, online), time);</para>
            </summary>
            <returns>0~95</returns>
        </member>
        <member name="F:EntryEngine._MATH.DIVIDE_BY_1">
            <summary>1 ~ 2048的倒数(reciprocal)</summary>
        </member>
        <member name="M:EntryEngine._MATH.Ceiling(System.Single)">
            <summary>
            大于浮点数的最小整数
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Round(System.Single)">
            <summary>
            四舍五入的整数
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            取两个数之间的值
            </summary>
            <param name="value">值</param>
            <param name="min">最小值</param>
            <param name="max">最大值</param>
            <returns>最小值与最大值之间的值</returns>
        </member>
        <member name="M:EntryEngine._MATH.InOne(System.Single)">
            <summary>
            0 ~ 1
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.InTwo(System.Single)">
            <summary>
            -1 ~ 1
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Positive(System.Single)">
            <summary>
            大于等于1
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Negative(System.Single)">
            <summary>
            小于等于0
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Nature(System.Single)">
            <summary>
            自然数
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Interval(System.Single)">
            <summary>
            区间：通过MinValue和MaxValue自定义区间
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.InByte(System.Single)">
            <summary>
            0 ~ 255
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Multiple(System.Single,System.Single)">
            <summary>
            倍数值：倍数20，取值则是20的倍数，如-20, 0, 20, 40
            </summary>
            <param name="multiple">倍数值</param>
            <returns>最接近倍数值倍数的值</returns>
        </member>
        <member name="M:EntryEngine._MATH.Near(System.Single,System.Single,System.Single)">
            <summary>
            近似值：值与近似值的差值小于差值则取近似值，否则取值
            </summary>
            <param name="near">近似值</param>
            <param name="diffrence">差值</param>
            <returns>近似值或者值</returns>
        </member>
        <member name="M:EntryEngine._MATH.CloseToSpeed(System.Single,System.Single,System.Single)">
            <summary>
            靠近目标值：100 -> 1，速度5，到5之前，return -5，然后return -4
            </summary>
            <param name="value">当前值</param>
            <param name="target">要靠近的目标值</param>
            <param name="speed">靠近速度（无论方向）</param>
            <returns>靠近速度（带方向）</returns>
        </member>
        <member name="M:EntryEngine._MATH.CloseTo(System.Single,System.Single,System.Single)">
            <summary>
            靠近目标值：100 -> 1，速度5，return 95,90...5,1
            </summary>
            <param name="value">当前值</param>
            <param name="target">要靠近的目标值</param>
            <param name="speed">靠近速度（无论方向）</param>
            <returns>靠近后的值</returns>
        </member>
        <member name="M:EntryEngine._MATH.CloseToAngle(System.Single,System.Single,System.Single)">
            <summary>
            靠近目标角度
            </summary>
            <param name="value">当前角度</param>
            <param name="target">目标角度</param>
            <param name="speed">靠近速度（无论方向）</param>
            <returns>靠近后的角度</returns>
        </member>
        <member name="M:EntryEngine._MATH.Range(System.Single,System.Single,System.Single)">
            <summary>
            将值转换为min ~ max区间内的值
            </summary>
            <param name="min">区间最小值</param>
            <param name="max">区间最大值</param>
            <returns>min ~ max</returns>
        </member>
        <member name="M:EntryEngine._MATH.Range(System.Single,System.Single)">
            <summary>
            将值转换为0 ~ max区间内的值（不包含max）
            </summary>
            <param name="max">区间最大值</param>
            <returns>0 ~ max</returns>
        </member>
        <member name="M:EntryEngine._MATH.RangeRate(System.Single,System.Single,System.Single)">
            <summary>
            值在区间内的比例
            </summary>
            <param name="min">区间最小值</param>
            <param name="max">区间最大值</param>
            <returns>值在区间内的比例</returns>
        </member>
        <member name="M:EntryEngine._MATH.RangeValue(System.Single,System.Single,System.Single)">
            <summary>
            百分比在区间内对应的值：比例小于0或大于1会溢出区间
            </summary>
            <param name="rate">比例</param>
            <param name="min">区间最小值</param>
            <param name="max">区间最大值</param>
            <returns>百分比在区间内对应的值</returns>
        </member>
        <member name="M:EntryEngine._MATH.Nomalize(System.Single,System.Single@,System.Single@)">
            <summary>
            将值缩放到规格范围内
            </summary>
            <param name="norm">规格</param>
            <param name="x">缩放x</param>
            <param name="y">缩放y</param>
            <returns>缩放规格</returns>
        </member>
        <member name="M:EntryEngine._MATH.Nomalize(System.Single@,System.Single@)">
            <summary>
            规格为1
            </summary>
        </member>
        <member name="M:EntryEngine._MATH.Nomalize(System.Single,System.Single[])">
            <summary>
            将值缩放到规格范围内
            </summary>
            <param name="norm">规格</param>
            <param name="values">要缩放的值</param>
            <returns>缩放规格</returns>
        </member>
        <member name="M:EntryEngine._MATH.NomalizeFactor(System.Single,System.Single[])">
            <summary>
            计算缩放规格
            </summary>
            <param name="norm">规格</param>
            <returns>缩放规格</returns>
        </member>
        <member name="M:EntryEngine._MATH.Dot(System.Single[])">
            <summary>
            a * a + b * b + c * c......
            </summary>
            <returns>a * a + b * b + c * c......</returns>
        </member>
        <member name="M:EntryEngine._MATH.CircumcircleRadius(System.Single,System.Single)">
            <summary>
            矩形外接圆半径
            </summary>
            <returns>外接圆半径</returns>
        </member>
        <member name="M:EntryEngine._MATH.TheThird(System.Single,System.Single)">
            <summary>
            Sqrt(a * a + b * b)
            </summary>
            <returns>Sqrt(a * a + b * b)</returns>
        </member>
        <member name="M:EntryEngine._MATH.Fibonacci(System.Int32)">
            <summary>
            斐波那契数列
            </summary>
            <param name="index">数列索引</param>
            <returns>数列中的项</returns>
        </member>
        <member name="M:EntryEngine._MATH.FibonacciInverse(System.Int32)">
            <summary>
            斐波那契数列逆运算
            </summary>
            <param name="value">数列值</param>
            <returns>数列中的索引</returns>
        </member>
        <member name="M:EntryEngine._MATH.FibonacciLevel(System.Int32,System.Int32,System.Int32)">
            <summary>
            斐波那契数列作为经验值的等级计算
            </summary>
            <param name="level">要达到的等级</param>
            <param name="exp">达到等级需要的经验</param>
            <param name="currentExp">当前经验</param>
            <returns>当前等级</returns>
        </member>
        <member name="M:EntryEngine._MATH.Arithmetic(System.Single,System.Single,System.Int32)">
            <summary>
            等差数列
            </summary>
            <param name="a0">等差数列的第一项</param>
            <param name="d">差值</param>
            <param name="n">项索引</param>
            <returns>第n项</returns>
        </member>
        <member name="M:EntryEngine._MATH.Geometric(System.Single,System.Single,System.Int32)">
            <summary>
            等比数列
            </summary>
            <param name="a0">等比数列第一项</param>
            <param name="q">比值</param>
            <param name="n">项索引</param>
            <returns>第n项</returns>
        </member>
        <member name="M:EntryEngine._MATH.Arrangement(System.Int32,System.Int32)">
            <summary>
            <para>排列</para>
            <para>有count个数，总共能组成多少个factor位数</para>
            <para>设count=9,factor=3,a93=9*8*7=504</para>
            </summary>
            <param name="count">总数</param>
            <param name="factor">位数</param>
            <returns>总共的排列数</returns>
        </member>
        <member name="M:EntryEngine._MATH.Combination(System.Int32,System.Int32)">
            <summary>
            <para>组合</para>
            <para>有count个人，factor人为一组，总共能组成多少个不同组合</para>
            <para>设count=9,factor=3,c93=(9*8*7)/(3*2*1)=84</para>
            </summary>
            <param name="count">总数</param>
            <param name="factor">组数</param>
            <returns>总共的组合数</returns>
        </member>
        <member name="M:EntryEngine._MATH.Combination``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            <para>组合</para>
            <para>有count个人，factor人为一组，总共能组成多少个不同组合</para>
            <para>设count=9,factor=3,c93=(9*8*7)/(3*2*1)=84</para>
            </summary>
            <param name="array">要组合的数组</param>
            <param name="factor">组数</param>
            <returns>所有的组合结果</returns>
        </member>
        <member name="M:EntryEngine._MATH.CombinationRight``1(``0[],System.Int32,System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            将组合视为树队列，每个节点不断向右
            父节点向右一次，子节点都需要向右到最后
            </summary>
            <param name="result">组合结果</param>
            <param name="index">队列进入组合的索引</param>
            <param name="array">队列</param>
            <param name="queue">队列索引</param>
            <returns>所有的组合结果</returns>
        </member>
        <member name="M:EntryEngine._MATH.Arrangement``1(System.Collections.Generic.IList{``0})">
            <summary>
            数组的全排列
            </summary>
            <param name="array">需要得出全排列的数组</param>
            <returns>全排列项</returns>
        </member>
        <member name="M:EntryEngine._MATH.Arrangement``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            <para>排列</para>
            <para>有count个数，总共能组成多少个factor位数</para>
            <para>设count=9,factor=3,a93=9*8*7=504</para>
            </summary>
            <param name="array">要排列的数组</param>
            <param name="factor">位数</param>
            <returns>所有的排列结果</returns>
        </member>
        <member name="M:EntryEngine._MATH.ArrangementRight``1(``0[],System.Int32)">
            <summary>
            要排列的每个元素向后面的每个元素交换得出结果
            每个靠前的元素交换一次，后面的元素要重复次步骤
            </summary>
            <param name="array">待排列的数组</param>
            <param name="startIndex">交换的索引</param>
            <returns>数组的全排列</returns>
        </member>
        <member name="M:EntryEngine._MATH.MaxDivisor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>求一组正数的最大公约数</summary>
            <returns>最小为1</returns>
        </member>
        <member name="M:EntryEngine._MATH.Symmetry(System.Single,System.Single)">
            <summary>
            关于一个指定角度对称
            </summary>
            <param name="value">角度</param>
            <param name="angle">对称角</param>
            <returns>对称的角度</returns>
        </member>
        <member name="M:EntryEngine._MATH.SymmetryY(System.Single)">
            <summary>
            相对于Y轴的对称角
            </summary>
            <param name="value">角度</param>
            <returns>对称的角度</returns>
        </member>
        <member name="M:EntryEngine._MATH.SymmetryC(System.Single)">
            <summary>
            相对于原点的对称角
            </summary>
            <param name="value">角度</param>
            <returns>对称的角度</returns>
        </member>
        <member name="M:EntryEngine._MATH.SymmetryXY(System.Single)">
            <summary>
            相对于XY轴的对称角
            </summary>
            <param name="value">角度</param>
            <returns>对称的角度</returns>
        </member>
        <member name="M:EntryEngine._MATH.Closewise(System.Single,System.Single)">
            <summary>
            角度1到角度2顺时针还是逆时针比较近
            </summary>
            <param name="value">当前角</param>
            <param name="target">目标角</param>
            <returns>角度差（带方向）</returns>
        </member>
        <member name="M:EntryEngine._MATH.AngleDifference(System.Single,System.Single)">
            <summary>
            角度1到角度2顺时针还是逆时针比较近(角度范围必须是[-180~180])
            </summary>
            <param name="a1">当前角</param>
            <param name="a2">目标角</param>
            <returns>角度差（不带方向）</returns>
        </member>
        <member name="M:EntryEngine._MATH.WeightVary(System.Single,System.Single,System.Single)">
            <summary>权重变化</summary>
            <param name="weight">当前待改变的权重</param>
            <param name="total">总权重</param>
            <param name="multiple">权重变为原来的倍数</param>
            <returns>权重的变化量</returns>
        </member>
        <member name="M:EntryEngine._MATH.WeightVary(System.Single[],System.Single,System.Single)">
            <summary>批量权重变化，例如750,125,125三个权重，希望125,125的两个权重翻倍</summary>
            <param name="weights">待改变的权重(125,125)</param>
            <param name="total">总权重(1000)</param>
            <param name="multiple">权重变为原来的倍数(2)</param>
            <returns>每个权重的变化量(250,250)，即最终权重应该变为(750,125+250,125+250)->(750,375,375)</returns>
        </member>
        <member name="M:EntryEngine.__GRAPHICS.ViewAdapt(EntryEngine.VECTOR2,EntryEngine.VECTOR2,System.Single@,EntryEngine.VECTOR2@)">
            <summary>
            视口适配：计算画布要在屏幕内显示时的缩放和平移量
            </summary>
            <param name="graphics">画布尺寸</param>
            <param name="screen">屏幕尺寸</param>
            <param name="scale">缩放值</param>
            <param name="offset">平移值</param>
        </member>
        <member name="M:EntryEngine.__GRAPHICS.ViewDepth(EntryEngine.VECTOR2,EntryEngine.VECTOR2,EntryEngine.VECTOR2,EntryEngine.VECTOR2)">
            <summary>
            景深公式
            (远景-屏幕)/(焦距-屏幕)*偏移值
            宽高要分别计算
            </summary>
            <param name="faraway">远景尺寸</param>
            <param name="near">聚焦深度的尺寸，例如一张完整地图4000x2000</param>
            <param name="offset">聚焦深度的偏移值，例如地图向左偏移1000,向上偏移200，即-1000,-200</param>
            <param name="screen">屏幕尺寸，单屏尺寸，也可以理解为画布尺寸</param>
            <returns>远景偏移值</returns>
        </member>
        <member name="M:EntryEngine.__GRAPHICS.ViewDepth(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            (faraway - screen) / (near - screen) * offset
            </summary>
            <returns>(faraway - screen) / (near - screen) * offset</returns>
        </member>
        <member name="M:EntryEngine.__GRAPHICS.DrawMatrix(EntryEngine.RECT@,EntryEngine.RECT@,System.Single,EntryEngine.VECTOR2@,EntryEngine.EFlip,EntryEngine.MATRIX2x3@)">
            <summary>
            if need begin with the result matrix, you should set the rect's location to 0,0
            </summary>
        </member>
        <member name="M:EntryEngine.__GRAPHICS.DrawMatrixWithoutMirror(EntryEngine.RECT@,EntryEngine.RECT@,System.Single,EntryEngine.VECTOR2@,EntryEngine.MATRIX2x3@)">
            <summary>
            if need begin with the result matrix, you should set the rect's location to 0,0
            </summary>
        </member>
        <member name="M:EntryEngine.__GRAPHICS.CalcOrigin(System.Single,System.Single,System.Single)">
            <summary>通过像素差计算锚点，例如绘制200x200的图片到1000x1000的画布中的100x100的位置，锚点在画布中央，则p=[100,100],s=200,op=[500,500]</summary>
            <param name="position">从0开始到绘制区域宽度或高度的位置</param>
            <param name="size">当前绘制图片的最大宽度或高度</param>
            <param name="originPosition">从0开始到绘制区域宽度或高度的锚点位置</param>
            <returns>绘制用的锚点位置</returns>
        </member>
        <member name="M:EntryEngine._RANDOM.Random.ResetRandom(System.Int32)">
            <summary>
            重置随机
            </summary>
            <param name="seed">随机种子</param>
        </member>
        <member name="M:EntryEngine._RANDOM.Random.Next">
            <summary>
            随机0~int.MaxValue之间的数
            </summary>
            <returns>0 ~ int.MaxValue</returns>
        </member>
        <member name="M:EntryEngine._RANDOM.Random.NextDouble">
            <summary>
            随机0~1之间的数
            </summary>
            <returns>0 ~ 1</returns>
        </member>
        <member name="P:EntryEngine._RANDOM.Random.Seed">
            <summary>
            当前随机种子
            </summary>
        </member>
        <member name="P:EntryEngine._RANDOM.Random.Count">
            <summary>
            当前已随机的次数
            </summary>
        </member>
        <member name="M:EntryEngine.UI.Selectable.ListViewSelect(EntryEngine.UI.Panel)">
            <summary>Panel的子控件必须实现ISelectable</summary>
        </member>
        <member name="E:EntryEngine.UI.Selectable.SelectHandle">
            <summary>返回true时会选中Hover的项</summary>
        </member>
        <member name="T:EntryEngine.Serialize.SerializeSetting">
            <summary>
            反射GetField(string name)被调用后，接着调用GetFields()
            类型的Field顺序将被打乱，GetField的字段将被提到第一位
            所以应尽量使用此类型的GetProperties和GetFields获取所有成员再使用FirstOrDefault查找
            此时可以使用默认实例SettingSerializeAll
            </summary>
        </member>
        <member name="F:EntryEngine.Serialize.SerializeSetting.Static">
            <summary>
            序列化静态变量，只用于首个类型
            <value>True: 静态变量</value>
            <value>False: 实例变量</value>
            </summary>
        </member>
        <member name="F:EntryEngine.Serialize.SerializeSetting.Property">
            <summary>
            序列化属性
            </summary>
        </member>
        <member name="M:EntryEngine.Serialize.SerializeSetting.Serialize(System.Type,System.Object,System.Action{EntryEngine.Serialize.VariableObject})">
            <summary>使用GetVariables，静态相关的逻辑需要测试</summary>
        </member>
        <member name="P:EntryEngine.Serialize.SerializeSetting.DefaultSetting">
            <summary>
            用于所有序列化的默认设置
            </summary>
        </member>
        <member name="T:EntryEngine.Serialize._SERIALIZE">
            <summary>
            1. StringBuilder.AppendLine() { Append(Environment.NewLine); }: .net = \r\n, mono = \n
            </summary>
        </member>
        <member name="M:EntryEngine.Serialize._SERIALIZE.SimpleAQName(System.Type)">
            <summary>短AQ名在加密方式加载下的程序集中还是未能通过Type.GetType获得类型</summary>
        </member>
        <member name="F:EntryEngine.Network.LoginResult.Agent">
            <summary>
            Agent is null: Not a new client
            </summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.LinkCountOver">
            <summary>服务器连接数过多</summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.ClientClose">
            <summary>登录流程中客户端关闭了连接</summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.ServerClose">
            <summary>登录流程中服务器关闭了连接</summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.Refuse">
            <summary>登录被拒绝</summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.CannotLogin">
            <summary>登录流程结束也没能正确登录</summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.Exception">
            <summary>登录流程发生了异常</summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.Timeout">
            <summary>登录超时</summary>
        </member>
        <member name="F:EntryEngine.Network.EAcceptClose.Login">
            <summary>登录完毕</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.PermitAcceptCount">
            <summary>限定最大接入数</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.PermitAcceptEndPoint">
            <summary>限定指定终端接入</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.LinkTimeout">
            <summary>连接验证包超时(ms)</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.PermitSameIPLinkPerSecord">
            <summary>限定每秒允许同一个IP的接入数</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.SameIPLinkPerSecondBlock">
            <summary>限定每秒允许同一个IP的接入数，超过则禁止该IP登录</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.PermitAcceptTimeout">
            <summary>每帧Accept的最长时间</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.PermitReceiveTimeout">
            <summary>每个Client接收处理数据包最长时间</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.CatchUpdate">
            <summary>值为false时，OnUpdate的异常会被抛出，可能导致服务的关闭</summary>
        </member>
        <member name="F:EntryEngine.Network.Proxy.Heartbeat">
            <summary>
            <para>大于0. 到时间会发送心跳包，包发不出去将结束心跳</para>
            <para>等于0. 不关心心跳</para>
            <para>小于0. 到时间(绝对值)会直接视为断线</para>
            </summary>
        </member>
        <member name="F:EntryEngine.Network.LinkHttpResponseShort.MAX_PUSH_CACHE_SIZE">
            <summary>由于短连接的特性，未能由服务器主动推送出去的数据将会被缓存，超过此尺寸时，缓存将被清空，负数则允许无限增大</summary>
        </member>
        <member name="F:EntryEngine.Network.AgentHttp.OnReset">
            <summary>一次OnProtocol处理完一个请求时触发</summary>
        </member>
        <member name="M:EntryEngine.Network.ParallelRouter`1.AddRouter(System.Func{`0,System.Int32},EntryEngine.Network.ParallelQueue{`0}[])">
            <param name="getToken">返回值必须大于等于0时分配工作队列，相同的返回值会分配到相同的工作队列；返回值小于0时不工作</param>
        </member>
        <member name="F:EntryEngine.Network.ParallelQueue`1.tokenJobs">
            <summary>key:某个角色 / value:工作数量</summary>
        </member>
        <member name="M:EntryEngine.Network.ParallelJsonHttpService.HotFixAgent(System.Reflection.MethodInfo)">
            <summary>热更新Agent处理协议：StubHttp[] Method(Func&lt;HttpListenerContext> getData)</summary>
        </member>
        <member name="M:EntryEngine.Network.ParallelBinaryService`1.HotFixAgent(System.Reflection.MethodInfo)">
            <summary>热更新Agent处理协议：Stub[] Method(Func&lt;T> getData)</summary>
        </member>
        <member name="F:EntryEngine.EPlatform.Desktop">
            <summary>
            PC
            </summary>
        </member>
        <member name="F:EntryEngine.EPlatform.Mobile">
            <summary>
            移动设备
            </summary>
        </member>
        <!-- 对于成员“F:EntryEngine.EPlatform.Console”忽略有格式错误的 XML 注释 -->
        <member name="P:EntryEngine.IPlatform.Platform">
            <summary>平台</summary>
        </member>
        <member name="P:EntryEngine.IPlatform.FrameRate">
            <summary>一帧的时间</summary>
        </member>
        <member name="P:EntryEngine.IPlatform.IsMouseVisible">
            <summary>指针是否可见</summary>
        </member>
        <member name="P:EntryEngine.IPlatform.IsActive">
            <summary>当前程序是否激活，激活将更新用户操作</summary>
        </member>
        <member name="M:EntryEngine.IInputState.IsClick(System.Int32)">
            <summary>
            是否点击
            </summary>
            <param name="key">0:左键 / 1:右键 / 2:中键 / 自定义按键</param>
            <returns>是否点击</returns>
        </member>
        <member name="P:EntryEngine.IPointerState.Position">
            <summary>
            坐标
            </summary>
        </member>
        <member name="M:EntryEngine.IKeyboardState.GetPressedKey">
            <summary>
            按下的所有键
            </summary>
        </member>
        <member name="P:EntryEngine.Input`1.DefaultKey">
            <summary>默认键</summary>
        </member>
        <member name="F:EntryEngine.KEYBOARD.KeyInputInterval">
            <summary>ComboClick.IsKeyActive(ms)</summary>
        </member>
        <member name="F:EntryEngine.ComboClick.ComboTime">
            <summary>
            连续点击有效时间
            </summary>
        </member>
        <member name="M:EntryEngine.ComboClick.#ctor(System.Single)">
            <summary>
            多次点击
            </summary>
            <param name="doubleClickInternal">双击判定时间</param>
        </member>
        <member name="M:EntryEngine.ComboClick.IsKeyActive(System.Single)">
            <summary>
            按键是否有效，首次按下有效 / 持续按下超过双击时间后持续有效
            </summary>
        </member>
        <member name="P:EntryEngine.ComboClick.ClickCount">
            <summary>
            连续点击次数
            </summary>
        </member>
        <member name="P:EntryEngine.ComboClick.PressedTime">
            <summary>
            按键按下时间（ms）
            </summary>
        </member>
        <member name="P:EntryEngine.ComboClick.IsComboClickActive">
            <summary>
            是否处于连续点击的有效时间内
            </summary>
        </member>
        <member name="T:EntryEngine.Pointer`1">
            <summary>
            升级到.net4.0就可以对泛型T使用out关键字，Pointer`IPointerState就可以等于MOUSE或TOUCH实例了，目前则使用IPointer接口
            </summary>
        </member>
        <member name="F:EntryEngine.Pointer`1.TapTime">
            <summary>
            轻击按下最长时间(ms)
            </summary>
        </member>
        <member name="F:EntryEngine.Pointer`1.TapDistance">
            <summary>
            轻击拖动最长距离(px)
            </summary>
        </member>
        <member name="P:EntryEngine.Pointer`1.Position">
            <summary>Position in Graphcis</summary>
        </member>
        <member name="T:EntryEngine.MOUSE">
            <summary>
            0: Left
            1: Right
            2: Middle
            </summary>
        </member>
        <member name="T:EntryEngine.SingleTouch`1">
            <summary>
            可以用IMouseState模拟单个Touch
            </summary>
            <typeparam name="T">IMouseState或ITouchState</typeparam>
        </member>
        <member name="M:EntryEngine.TOUCH.GetTouches(EntryEngine.ITouchState[])">
            <summary>
            刷新TouchState到缓存
            </summary>
            <param name="states">前一帧的states缓存</param>
            <returns>Touch的数量</returns>
        </member>
        <member name="P:EntryEngine.TOUCH.TouchExpand">
            <summary>
            扩大
            </summary>
        </member>
        <member name="P:EntryEngine.TOUCH.TouchReduce">
            <summary>
            缩小
            </summary>
        </member>
        <member name="P:EntryEngine.TOUCH.Scale">
            <summary>
            缩放
            </summary>
        </member>
        <member name="P:EntryEngine.TOUCH.Rotate">
            <summary>
            旋转
            </summary>
        </member>
        <member name="T:EntryEngine.EInputText">
            <summary>
            所有要实现的文本操作
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Char">
            <summary>
            输入字符
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.BackSpace">
            <summary>
            删除字符（前）
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Tab">
            <summary>
            Tab \t
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Enter">
            <summary>
            确认 Ctrl + Enter \n
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Newline">
            <summary>
            换行 Enter \r
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Esc">
            <summary>
            取消
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Delete">
            <summary>
            删除字符（后）
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Select">
            <summary>
            选择 Shift L:160 R:161
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Skip">
            <summary>
            同类字符跳过 Ctrl L:162 R:163
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.End">
            <summary>
            移位到行尾
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Home">
            <summary>
            移位到行首
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Left">
            <summary>
            左移位
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Up">
            <summary>
            上移位
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Right">
            <summary>
            右移位
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Down">
            <summary>
            下移位
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.SelectAll">
            <summary>
            全选 Ctrl + A
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Copy">
            <summary>
            复制 Ctrl + C
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Paste">
            <summary>
            粘贴 Ctrl + V
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Cut">
            <summary>
            剪切 Ctrl + X
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Redo">
            <summary>
            重做 Ctrl + Y
            </summary>
        </member>
        <member name="F:EntryEngine.EInputText.Undo">
            <summary>
            撤销 Ctrl + Z
            </summary>
        </member>
        <member name="M:EntryEngine.InputText.Focus(System.Int32,System.Boolean)">
            <summary>
            设置索引
            </summary>
            <param name="index">当前索引</param>
            <param name="select">是否为选中索引</param>
        </member>
        <member name="P:EntryEngine.InputText.ImmCapturing">
            <summary>
            正在输入法里打字，此时的键盘快捷键操作将无效
            </summary>
        </member>
        <member name="M:EntryEngine.ContentPipeline.Wait``1(EntryEngine.AsyncLoadContent,System.Collections.Generic.IEnumerable{``0},System.Byte,System.Func{EntryEngine.Content})">
            <summary>
            等待其它异步队列完成
            </summary>
            <typeparam name="T">等待异步类型</typeparam>
            <param name="load">异步加载结果</param>
            <param name="asyncs">等待的异步队列</param>
            <param name="executeCount">队列有完成时继续执行的个数，等于0则全部同步完成</param>
            <param name="result">完成时加载的结果</param>
        </member>
        <member name="P:EntryEngine.ContentPipeline.SuffixProcessable">
            <summary>
            可处理的源文件类型
            <para>null: 可以处理所有类型</para>
            </summary>
        </member>
        <member name="P:EntryEngine.ContentPipeline.FileType">
            <summary>
            源文件输出以及最终能加载的文件类型，以源文件类型加载则值应为null
            </summary>
        </member>
        <member name="F:EntryEngine.Content.IsMain">
            <summary>Cache不会被Dispose</summary>
        </member>
        <member name="M:EntryEngine.AsyncLoadContent.OnSetData(EntryEngine.Content@)">
            <summary>
            Queue加载的项也会重复的设置
            像PIECE这样的内容，重复设置的Content将前后不相等，导致Manager[Key]里Dispose之前的Content
            </summary>
        </member>
        <member name="T:EntryEngine.SoundSource">
            <summary>可延迟加载的声音</summary>
        </member>
        <member name="M:EntryEngine.SoundSource.SetLoop(System.Boolean)">
            <summary>设置是否循环</summary>
        </member>
        <member name="P:EntryEngine.SoundSource.State">
            <summary>播放状态</summary>
        </member>
        <member name="P:EntryEngine.SoundSource.Volume">
            <summary>音量(0 ~ 1)</summary>
        </member>
        <member name="P:EntryEngine.SoundSource.Channel">
            <summary>声道(-1左 ~ 1右)</summary>
        </member>
        <member name="F:EntryEngine.AUDIO.MaxDistance">
            <summary>3D音效能听到声音的最远距离</summary>
        </member>
        <member name="P:EntryEngine.AUDIO.Volume">
            <summary>0 ~ 1</summary>
        </member>
        <member name="P:EntryEngine.AUDIO.Mute">
            <summary>是否静音</summary>
        </member>
        <member name="P:EntryEngine.AUDIO.ListenerLocation">
            <summary>侦听坐标</summary>
        </member>
        <member name="F:EntryEngine.TEXTURE.SPECIAL_TEXTURE_TYPE">
            <summary>只是更换了后缀的png文件，由组合大图工具生成</summary>
        </member>
        <member name="T:EntryEngine.TEXTURE_SYSTEM">
            <summary>系统图片素材不会被释放掉</summary>
        </member>
        <member name="T:EntryEngine.TEXTURE_DELAY">
            <summary>可延迟加载的图片</summary>
        </member>
        <member name="F:EntryEngine.PIECE.SourceRectangle">
            <summary>宽高就是图像的尺寸</summary>
        </member>
        <member name="F:EntryEngine.PIECE.Padding">
            <summary>宽高分别是右边和下边的尺寸</summary>
        </member>
        <member name="F:EntryEngine.PATCH.Anchor">
            <summary>左上 Body宽高[不是右下]</summary>
        </member>
        <member name="P:EntryEngine.PipelinePatch.FileType">
            <summary>
            mtpatch: Metadata of Texture Patch
            </summary>
        </member>
        <member name="M:EntryEngine.ANIMATION.NextFrame">
            <summary>
            下一帧
            </summary>
            <returns>序列动画是否播放完毕</returns>
        </member>
        <member name="M:EntryEngine.ANIMATION.Play(System.String)">
            <returns>成功更换动画</returns>
        </member>
        <member name="M:EntryEngine.ANIMATION.Update(System.Single)">
            <returns>动画播放完毕</returns>
        </member>
        <member name="F:EntryEngine.Frame.Interval">
            <summary>秒</summary>
        </member>
        <member name="P:EntryEngine.PipelineAnimation.FileType">
            <summary>mtseq: Metadata of Sequence</summary>
        </member>
        <member name="T:EntryEngine.TILE">
            <summary>
            未实现绘制指定SourceRectangle
            待实现循环轮播的背景图片
            </summary>
        </member>
        <member name="P:EntryEngine.TILE.TileX">
            <summary>横向平铺的次数</summary>
        </member>
        <member name="P:EntryEngine.TILE.TileY">
            <summary>纵向平铺的次数</summary>
        </member>
        <member name="T:EntryEngine.PICTURE">
            <summary>
            将多张小图按照一定的位置摆放成一张大图，需特殊编辑器
            未实现绘制指定SourceRectangle
            </summary>
        </member>
        <member name="M:EntryEngine.FONT.MeasureString(System.Func{System.Char,System.Single},System.Single,System.String)">
            <summary>
            测量等宽字体字符串的尺寸
            </summary>
            <param name="calcWidth">计算字符宽度</param>
            <param name="height">行高</param>
            <param name="text">要测量的文字</param>
            <returns>文字的宽高</returns>
        </member>
        <member name="M:EntryEngine.FONT.BreakLine(System.Func{System.Char,System.Single},System.Single,System.String,System.Single,System.String[]@)">
            <summary>
            自动换行
            </summary>
            <param name="calcWidth">计算字符宽度</param>
            <param name="height">行高</param>
            <param name="text">字符串</param>
            <param name="width">行宽</param>
            <param name="lines">拆分后的每行字符串</param>
            <returns>换行后的字符串</returns>
        </member>
        <member name="M:EntryEngine.FONT.Cursor(System.Func{System.Char,System.Single},System.Single,System.String,System.Int32)">
            <summary>
            光标在一段文字中的坐标
            </summary>
            <param name="calcWidth">计算字符宽度</param>
            <param name="height">行高</param>
            <param name="text">字符串</param>
            <param name="index">索引</param>
            <returns>坐标</returns>
        </member>
        <member name="M:EntryEngine.FONT.CursorIndex(System.Func{System.Char,System.Single},System.Single,System.String,EntryEngine.VECTOR2)">
            <summary>
            获得鼠标在文字内容中的索引
            </summary>
            <param name="calcWidth">计算字符宽度</param>
            <param name="height">行高</param>
            <param name="text">内容</param>
            <param name="mouse">鼠标坐标</param>
            <returns>光标在文字内容中的索引</returns>
        </member>
        <member name="M:EntryEngine.FONT.SimilarChar(System.String,System.Int32)">
            <summary>
            查找索引处字符相似的字符的连续字符串
            </summary>
            <param name="text">要查找的字符串</param>
            <param name="index">相似字符的索引位置</param>
            <returns>相似字符的索引范围</returns>
        </member>
        <member name="M:EntryEngine.FONT.ChangeIndex(System.String,System.Int32,System.String)">
            <summary>
            将自动换行的字符串中的索引映射到没换行前的字符串内
            </summary>
            <param name="current">自动换行后的文字</param>
            <param name="index">换行后文字内的索引</param>
            <param name="previous">没换行前的文字</param>
            <returns>没换行前文字内的索引</returns>
        </member>
        <member name="M:EntryEngine.FONT.IndexLineText(System.String,System.Int32)">
            <summary>
            文字中索引所在的行的文字
            </summary>
            <param name="text">文字</param>
            <param name="index">索引</param>
            <returns>索引所在行的文字</returns>
        </member>
        <member name="M:EntryEngine.FONT.IndexForRowCol(System.String,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            文字中索引所在的行与列索引
            </summary>
            <param name="text">文字</param>
            <param name="index">索引</param>
            <param name="start">文字开始索引</param>
            <param name="count">文字数量</param>
            <param name="row">行索引</param>
            <param name="col">列索引</param>
        </member>
        <member name="P:EntryEngine.FONT.FontSize">
            <summary>
            字体尺寸（单位：像素）
            </summary>
        </member>
        <member name="F:EntryEngine.FontTexture.Buffer.Space">
            <summary>字的间隔，默认等于W</summary>
        </member>
        <member name="P:EntryEngine.PipelineFontStatic.FileType">
            <summary>
            mtsfont: Metadata of static font
            </summary>
        </member>
        <member name="F:EntryEngine.FontDynamic.StaticStep">
            <summary>字体大小相差不大时，采用静态字体缩放</summary>
        </member>
        <member name="T:EntryEngine.EViewport">
            <summary>屏幕适配</summary>
        </member>
        <member name="F:EntryEngine.EViewport.None">
            <summary>画布尺寸保持与屏幕尺寸一样</summary>
        </member>
        <member name="F:EntryEngine.EViewport.Adapt">
            <summary>保持画布分辨率比例拉升自动适配屏幕</summary>
        </member>
        <member name="F:EntryEngine.EViewport.Strength">
            <summary>拉伸画布分辨率到屏幕分辨率</summary>
        </member>
        <member name="F:EntryEngine.EViewport.Keep">
            <summary>画布尺寸始终保持不变，当屏幕尺寸大于画布尺寸时，画布居中</summary>
        </member>
        <member name="T:EntryEngine.GRAPHICS">
            <summary>
            OriginX, OriginY是相对于SourceRectangle的百分比数字，例如0.5,0.5就是图像居中绘制
            </summary>
        </member>
        <member name="F:EntryEngine.GRAPHICS.Culling">
            <summary>绘制前检测对象是否在视口内，不在视口内则跳过绘制，若绘制性能高则不建议开启此检测</summary>
        </member>
        <member name="M:EntryEngine.GRAPHICS.ToPixel(EntryEngine.VECTOR2)">
            <summary>
            计算需要的像素在分辨率下缩放的值
            例如原分辨率下1px的对象，在缩放后可能不足1px而导致不显示
            </summary>
            <param name="pixel">原分辨率下的像素值</param>
            <returns>固定分辨率里显示的值</returns>
        </member>
        <member name="M:EntryEngine.GRAPHICS.BeginFromPrevious(EntryEngine.MATRIX2x3,EntryEngine.RECT)">
            <summary>在之前的矩阵的基础上开始绘制</summary>
        </member>
        <member name="M:EntryEngine.GRAPHICS.Screenshot(EntryEngine.RECT,System.Action{EntryEngine.TEXTURE})">
            <summary>截屏只能截取到屏幕尺寸而不是画布尺寸</summary>
        </member>
        <member name="M:EntryEngine.GRAPHICS.BeginScreenshot(EntryEngine.RECT)">
            <summary>视框架的支持情况，可能可以截取到指定画布尺寸</summary>
        </member>
        <member name="M:EntryEngine.GRAPHICS.DrawPrimitives(EntryEngine.TEXTURE,EntryEngine.TextureVertex[],System.Int32,System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>三角形绘制</summary>
        </member>
        <member name="M:EntryEngine.GRAPHICS.CreateTriangleIndexData(System.Int32)">
            <summary>每6个为一组按的索引0,1,2,0,2,3</summary>
        </member>
        <member name="M:EntryEngine.GRAPHICS.CreateOrderIndexData(System.Int32)">
            <summary>每3个为一组按顺序的索引0,1,2,1,2,3,2,3,4</summary>
        </member>
        <member name="F:EntryEngine.GraphicsDeviceCPU.EColorFlag.Linear">
            <summary>
            线性计算每个像素点的值
            </summary>
        </member>
        <member name="F:EntryEngine.GraphicsDeviceCPU.EColorFlag.Fixed">
            <summary>
            固定计算像素点的值
            </summary>
        </member>
        <member name="F:EntryEngine.GraphicsDeviceCPU.EColorFlag.Ignore">
            <summary>
            不计算颜色的值
            </summary>
        </member>
        <member name="T:EntryEngine._LOG">
            <summary>
            Debug   : 测试时信息
            Info    : 功能关键信息
            Warning : 错误的操作信息
            Error   : 抛出且截获的异常
            --Fatal   : 抛出且未截获的异常
            </summary>
        </member>
        <member name="F:EntryEngine.Network.MergeTable.Where">
            <summary>
            <para>SELECT * FROM TABLE 后的筛选条件，符合条件的数据将被留下，如下</para>
            <para>WHERE registTime > '2016/7/20'</para>
            <para>JOIN ON playerinfo ON (TABLE.uid = playerinfo.uid) WHERE level > 10</para>
            </summary>
        </member>
        <member name="F:EntryEngine.Network.EIndex.Index">
            <summary>
            索引：用于查询
            </summary>
        </member>
        <member name="F:EntryEngine.Network.EIndex.Primary">
            <summary>
            主键：添加时要测重
            <para>多主键时，每个主键生成Group</para>
            <para>所有主键生成一个复合主键类型，由此类型生成</para>
            </summary>
        </member>
        <member name="F:EntryEngine.Network.EIndex.Identity">
            <summary>
            自增：视为主键
            </summary>
        </member>
        <member name="F:EntryEngine.Network.EIndex.Group">
            <summary>
            分组：例如同一个玩家的操作记录
            </summary>
        </member>
        <member name="T:EntryEngine.Network.IgnoreAttribute">
            <summary>数据库不生成标记此特性的字段</summary>
        </member>
        <member name="T:EntryEngine.Network.PagedModel`1">
            <summary>翻页数据模型</summary>
        </member>
        <member name="T:EntryEngine.Network.IInnerCascade">
            <summary>内部级联的树状关系，例如分类和二级分类，账号和邀请账号等</summary>
        </member>
        <member name="P:EntryEngine.Network.IInnerCascade.Parents">
            <summary>父类的级联数组，格式为0,1,2，越靠前计别越高</summary>
        </member>
        <member name="T:EntryEngine.UI.STextHint">
            <summary>屏幕中央弹出提示文字，常用于提示错误信息</summary>
        </member>
        <member name="T:EntryEngine.UI.SFade">
            <summary>屏幕全黑或全白的淡入淡出，常用于切换场景</summary>
        </member>
        <member name="P:EntryEngine.UI.SFade.FadeOverSecond">
            <summary>渐变完成所需时间，单位秒</summary>
        </member>
        <member name="T:EntryEngine.UI.SMask">
            <summary>弹出子场景，子场景以外的部分遮罩</summary>
        </member>
        <member name="T:EntryEngine.UI.SPages">
            <summary>翻页按钮场景</summary>
        </member>
        <member name="T:EntryEngine.UI.STip">
            <summary>提示框</summary>
        </member>
        <member name="M:EntryEngine.VECTOR2.Towards(EntryEngine.VECTOR2@,EntryEngine.VECTOR2@,System.Single,System.Single@)">
            <summary>
            朝向目标点
            </summary>
            <param name="current">当前坐标</param>
            <param name="target">目标坐标</param>
            <param name="angle">当前方向</param>
            <param name="direction">朝向目标角度最近的角度（带方向）</param>
        </member>
        <member name="M:EntryEngine.VECTOR2.Barycentric(EntryEngine.VECTOR2@,EntryEngine.VECTOR2@,EntryEngine.VECTOR2@,System.Single,System.Single,EntryEngine.VECTOR2@)">
            <summary>
            质心 / 重心：三条中线的交点
            </summary>
            <param name="u">value1 -> value2</param>
            <param name="v">value1 -> value3</param>
        </member>
        <member name="M:EntryEngine.VECTOR2.Barycentric(EntryEngine.VECTOR2@,EntryEngine.VECTOR2@,EntryEngine.VECTOR2@,EntryEngine.VECTOR2@,System.Single@,System.Single@)">
            <summary>
            质心权重 value1: w = 1 - u - v
            </summary>
            <param name="u">value2</param>
            <param name="v">value3</param>
        </member>
        <member name="T:EntryEngine.COLOR">
            <summary>Xna3.1的颜色是BGRA</summary>
        </member>
        <member name="M:EntryEngine.COLOR.ColorInverse(EntryEngine.COLOR)">
            <summary>
            颜色的反转色 255 - value
            </summary>
            <param name="color">要反转的颜色</param>
            <returns>反转颜色值后的颜色</returns>
        </member>
        <member name="M:EntryEngine.COLOR.ColorNormal(System.Byte,System.Byte,System.Byte)">
            <summary>
            正常叠加模式
            </summary>
            <param name="value">混合色</param>
            <param name="alpha">混合色透明度</param>
            <param name="background">背景色</param>
            <returns>结果色</returns>
        </member>
        <member name="M:EntryEngine.COLOR.ColorNormalEx(System.Byte,System.Byte,System.Byte)">
            <summary>
            正常模式的逆运算
            </summary>
            <param name="value">结果色</param>
            <param name="alpha">混合色透明度</param>
            <param name="background">背景色</param>
            <returns>混合色</returns>
        </member>
        <member name="M:EntryEngine.COLOR.ColorScreen(System.Byte,System.Byte)">
            <summary>
            滤色
            </summary>
            <param name="value">源颜色(上层颜色)</param>
            <param name="filter">过滤色(下层颜色)</param>
            <returns>滤色后的值</returns>
        </member>
        <member name="M:EntryEngine.COLOR.ClearColor(EntryEngine.COLOR,EntryEngine.COLOR)">
            <summary>
            清除指定颜色
            </summary>
            <param name="rgb">当前颜色</param>
            <param name="clear">要清除的颜色</param>
            <returns>清除颜色后的颜色</returns>
        </member>
        <member name="M:EntryEngine.COLOR.ColorAlpha(EntryEngine.COLOR)">
            <summary>
            使用滤色通过颜色的RGB计算Alpha
            </summary>
            <param name="rgb">RGB颜色</param>
            <returns>颜色的Alpha</returns>
        </member>
        <member name="M:EntryEngine.LINE.#ctor(System.Single,System.Single,System.Single)">
            <summary>一般式 ax + by + c = 0</summary>
        </member>
        <member name="M:EntryEngine.LINE.IsOverlap(EntryEngine.LINE)">
            <summary>重合 A1/A2=B1/B2=C1/C2</summary>
        </member>
        <member name="M:EntryEngine.LINE.IsParallel(EntryEngine.LINE)">
            <summary>平行 A1/A2=B1/B2≠C1/C2</summary>
        </member>
        <member name="M:EntryEngine.LINE.IsVertical(EntryEngine.LINE)">
            <summary>垂直 A1A2+B1B2=0</summary>
        </member>
        <member name="M:EntryEngine.LINE.Distance(EntryEngine.VECTOR2)">
            <summary>点到直线的距离 d = |Ax0+By0+C| / √(A^2+B^2)</summary>
        </member>
        <member name="M:EntryEngine.LINE.DistanceWithSign(EntryEngine.VECTOR2)">
            <summary>距离符号代表在直线的顺时针还是逆时针一侧，不过这和直线的方向有关</summary>
        </member>
        <member name="M:EntryEngine.LINE.Distance(EntryEngine.LINE)">
            <summary>平行线之间的距离 d = |C1-C2| / √(A^2+B^2)</summary>
        </member>
        <member name="M:EntryEngine.LINE.Symmetrical(EntryEngine.VECTOR2)">
            <summary>一点关于直线对称的点 [x0-2A(Ax0+By0+C)/(A^2+B^2) , y0-2B(Ax0+By0+C)/(A^2+B^2)]</summary>
        </member>
        <member name="M:EntryEngine.LINE.Reverse">
            <summary>使直线方向相反</summary>
        </member>
        <member name="M:EntryEngine.LINE.LinePointAngle(System.Single,EntryEngine.VECTOR2)">
            <summary>点斜式 y - y0 = tan(angle)(x - x0)</summary>
        </member>
        <member name="M:EntryEngine.LINE.LinePointK(System.Single,EntryEngine.VECTOR2)">
            <summary>点斜式 y - y0 = k(x - x0)</summary>
        </member>
        <member name="M:EntryEngine.LINE.LineMultiPoint(EntryEngine.VECTOR2,EntryEngine.VECTOR2)">
            <summary>两点式 (y - y1) / (y2 - y1) = (x - x1) / (x2 - x1)</summary>
        </member>
        <member name="M:EntryEngine.LINE.LineIntercept(System.Single,System.Single)">
            <summary>截距式 x / a + y / b = 1</summary>
        </member>
        <member name="M:EntryEngine.LINE.LineInterceptY(System.Single,System.Single)">
            <summary>斜截式 y = kx + b</summary>
        </member>
        <member name="M:EntryEngine.RECT.ScaleMultiple(EntryEngine.UI.EPivot,System.Single,System.Single)">
            <summary>倍数缩放</summary>
            <param name="pivot">缩放锚点</param>
            <param name="x">横轴缩放倍数</param>
            <param name="y">纵轴缩放倍数</param>
        </member>
        <member name="M:EntryEngine.RECT.Scale(EntryEngine.UI.EPivot,System.Single,System.Single)">
            <summary>量缩放</summary>
            <param name="pivot">缩放锚点</param>
            <param name="x">横轴缩放量</param>
            <param name="y">纵轴缩放量</param>
        </member>
        <member name="M:EntryEngine.CIRCLE.TangentLine(System.Single,System.Single,EntryEngine.LINE@,EntryEngine.LINE@)">
            <summary>过一点得出圆的切线</summary>
        </member>
        <member name="F:EntryEngine.Graph`1.Digraph">
            <summary>是否为有向图。此属性针对添加和删除的父节点，而非被添加和被删除的子节点</summary>
        </member>
        <member name="M:EntryEngine.Graph`1.Navigate(`0,System.Int32,System.Func{`0,System.Boolean},`0)">
            <summary>
            寻路
            </summary>
            <param name="start">起始节点</param>
            <param name="breadth">最远距离</param>
            <param name="target">目标节点</param>
            <returns>寻路路径</returns>
        </member>
        <member name="M:EntryEngine.Graph`1.GPS(`0,System.Int32,System.Func{`0,System.Boolean},System.Func{EntryEngine.GraphPath{`0},System.Boolean})">
            <summary>
            广度优先循环图节点
            </summary>
            <param name="start">开始节点</param>
            <param name="breadth">广度，-1则循环整个图</param>
            <param name="visitable">节点是否可以访问</param>
            <param name="onNewNode">加入新节点的回调事件，返回true则中断循环</param>
            <returns>可访问的图节点</returns>
            <remarks>效率: EntryEngine.Timer=5000节点/20ms</remarks>
        </member>
        <member name="M:EntryEngine.Graph`1.Broadcast(`0,System.Int32,System.Func{`0,System.Boolean})">
            <summary>
            获得节点周围指定广度的节点
            </summary>
            <param name="start">开始节点</param>
            <param name="breadth">广度</param>
            <param name="visitable">节点是否可以访问</param>
            <returns>指定节点广度周围的节点（包含指定节点）</returns>
        </member>
        <member name="P:EntryEngine.GameTime.FrameID">
            <summary>不断累加的帧ID</summary>
        </member>
        <member name="P:EntryEngine.GameTime.OpenTime">
            <summary>入口开放时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.OpenedTotalTime">
            <summary>入口开放总时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.PreviousFrame">
            <summary>上一帧时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.CurrentFrame">
            <summary>当前帧时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.ElapsedTime">
            <summary>一帧经过的理论时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.ElapsedRealTime">
            <summary>一帧经过的真实时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.Elapsed">
            <summary>一帧经过的理论时间毫秒数</summary>
        </member>
        <member name="P:EntryEngine.GameTime.ElapsedSecond">
            <summary>经过的秒数</summary>
        </member>
        <member name="P:EntryEngine.GameTime.CurrentElapsed">
            <summary>当前帧经过的实时时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.UpdateElapsedTime">
            <summary>帧更新经过的时间</summary>
        </member>
        <member name="P:EntryEngine.GameTime.TickSecond">
            <summary>是否经过整秒</summary>
        </member>
        <member name="P:EntryEngine.GameTime.TickMinute">
            <summary>是否经过整分</summary>
        </member>
        <member name="P:EntryEngine.GameTime.TickHour">
            <summary>是否经过整点</summary>
        </member>
        <member name="P:EntryEngine.GameTime.TickDay">
            <summary>是否经过整天</summary>
        </member>
        <member name="P:EntryEngine.GameTime.TickMonth">
            <summary>是否经过整月</summary>
        </member>
        <member name="P:EntryEngine.GameTime.TickYear">
            <summary>是否经过整年</summary>
        </member>
        <!-- 对于成员“P:EntryEngine.GameTime.Second”忽略有格式错误的 XML 注释 -->
        <member name="P:EntryEngine.GameTime.Minute">
            <summary>经过到达的分</summary>
        </member>
        <member name="P:EntryEngine.GameTime.Hour">
            <summary>经过到达的时</summary>
        </member>
        <member name="P:EntryEngine.GameTime.Day">
            <summary>经过到达的天</summary>
        </member>
        <member name="P:EntryEngine.GameTime.Month">
            <summary>经过到达的月</summary>
        </member>
        <member name="P:EntryEngine.GameTime.Year">
            <summary>经过到达的年</summary>
        </member>
        <member name="T:EntryEngine.ADefaultValue">
            <summary>
            <para>静态类里定义的内部类或接口</para>
            <para>静态类将生成partial的部分，包含每个静态接口的一个对应的静态实例及调用实例的每个公开方法的静态方法</para>
            </summary>
        </member>
        <member name="P:EntryEngine.ADefaultValue.DefaultValue">
            <summary>
            生成的静态实例的默认值的类型(可以在非partial的静态类的静态构造函数手动构造默认值，此时需要增加#if !EntryBuilder)
            </summary>
        </member>
        <member name="T:EntryEngine.ADevice">
            <summary>
            跨平台设备
            </summary>
        </member>
        <member name="T:EntryEngine.ADeviceNew">
            <summary>
            构造函数创建跨平台设备
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.ToBeContinue">
            <summary>
            还未写完
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.BeNotTest">
            <summary>
            写完还未测试
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.Expand">
            <summary>
            待扩展
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.MayBeReform">
            <summary>
            或许会重整
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.LessUseful">
            <summary>
            不常用的
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.Test">
            <summary>
            测试用
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.BUG">
            <summary>
            有已知BUG
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.MayBeBUG">
            <summary>
            可能有BUG
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.Value">
            <summary>
            变量的跨平台通用值未定
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.Optimize">
            <summary>
            可以优化
            </summary>
        </member>
        <member name="F:EntryEngine.ECode.Attention">
            <summary>有需要注意的地方</summary>
        </member>
        <member name="T:EntryEngine.AInvariant">
            <summary>标识此特性的类型或程序集在重构代码或转换语言代码时类型及其成员不进行重命名，[不进行优化无引用成员（暂未实现，优化掉也貌似可以）]</summary>
        </member>
        <member name="T:EntryEngine.AReflexible">
            <summary>标识此特性的类型在重构代码时生成程序集信息</summary>
        </member>
        <member name="T:EntryEngine.ANonOptimize">
            <summary>标识此特性则不会被优化掉</summary>
        </member>
        <member name="T:EntryEngine.PoolHeap`1">
            <summary>
            池堆
            将BufferSize个对象视为一堆
            整个池能放满PoolSize堆时溢出
            </summary>
        </member>
        <member name="T:EntryEngine.CorDelegate">
            <summary>自定义委托完成协程</summary>
        </member>
        <member name="M:EntryEngine.CorEnumerator`1.Update(`0@)">
            <summary>执行下一项</summary>
            <param name="item">当前项</param>
            <returns>是否结束</returns>
        </member>
        <member name="F:EntryEngine.CLOCK.Duration">
            <summary>起止时间</summary>
        </member>
        <member name="F:EntryEngine.CLOCK.TickTime">
            <summary>时钟嘀嗒（取值-n仅一次:0每次:n间隔)</summary>
        </member>
        <member name="M:EntryEngine.Timeline`1.AddScriptFrame(System.Single,`0,System.Func{System.Single,`0,`0,`0})">
            <summary>自定义脚本关键帧</summary>
            <param name="script">时间，前一帧对象，后一帧对象，Return当前帧的值</param>
        </member>
        <member name="M:EntryEngine.Timeline`1.Expand(System.Single)">
            <summary>整体调整时间线时间</summary>
        </member>
        <member name="F:EntryEngine.ParticleStream.Skip">
            <summary>当前流更新一次后下次粒子将跳到当前流的后一个流处开始执行</summary>
        </member>
        <member name="F:EntryEngine.ParticleStream.Child">
            <summary>当前流的子流数量。当Update返回Flase时，Child为0则停止当前层次的流，Child不为0则仅跳过所有子流</summary>
        </member>
        <member name="M:EntryEngine.ParticleStream.Update(EntryEngine.Particle,EntryEngine.ParticleEmitter,System.Single)">
            <summary>
            更新粒子表现
            </summary>
            <param name="p">当前粒子</param>
            <param name="ps">粒子所属粒子系统，可以用于创建删除粒子</param>
            <param name="elapsed">经过时间，单位ms</param>
            <returns>是否继续更新后面的流</returns>
        </member>
        <member name="T:EntryEngine.PSRandom">
            <summary>若Random都采用同一个种子，会出现各种规律现象</summary>
        </member>
        <member name="F:EntryEngine.PSSpeed.Speed">
            <summary>每秒移动的像素</summary>
        </member>
        <member name="F:EntryEngine.PSSpeedCheck.Speed">
            <summary>每秒移动的像素</summary>
        </member>
        <member name="P:EntryEngine.Particle.Direction">
            <summary>力的方向（角度）</summary>
        </member>
        <member name="F:EntryEngine.ParticleSystem.Duration">
            <summary>粒子持续时间(s)</summary>
        </member>
        <member name="T:EntryEngine.SingleEncoding">
            <summary>char[]与byte[]直接转换，char>255则抛出异常</summary>
        </member>
        <member name="F:EntryEngine.Serialize.JsonReader.EJson.CURLY_OPEN">
            <summary>new object push</summary>
        </member>
        <member name="F:EntryEngine.Serialize.JsonReader.EJson.CURLY_CLOSE">
            <summary>new object pop</summary>
        </member>
        <member name="F:EntryEngine.Serialize.JsonReader.EJson.SQUARED_OPEN">
            <summary>'[' array object push</summary>
        </member>
        <member name="F:EntryEngine.Serialize.JsonReader.EJson.SQUARED_CLOSE">
            <summary>']' array object pop</summary>
        </member>
        <member name="F:EntryEngine.Serialize.JsonReader.EJson.COMMA">
            <summary>',' array object split</summary>
        </member>
        <member name="F:EntryEngine.Serialize.JsonReader.EJson.VALUE">
            <summary>Value</summary>
        </member>
    </members>
</doc>
